/* 2D n-body gravity simulator

 Note: as you'd expect, large numbers of particles at high gravity tend to
 collapse and merge.  Lower the gravity a bit, and they'll fly free again.
 
 Requires a 2D LED array and appropriate pixel mapper.
 
 MIT License
 
 Version  Author        Date      
 1.0.1    JEM(ZRanger1) 04/03/2021
*/ 

// display size - enter the dimensions of your matrix here
var width = 16;
var height = 16;

// Global variables for rendering
var frameBuffer = array(height);  
var frameTimer = 9999;           // accumulator for simulation timer
var clearFn = clearFrameBuffer;  // pointer to function to clear screen between frames

// Global variables for particle system
var _x = 0;   
var _y = 1;
var _dx = 2;
var _dy = 3;
var _hue = 4;

var MAX_PARTICLES = 32;     
export var numParticles = 3;
export var gravity = -8;    // gravitational acceleration constant
export var speed = 25;      // milliseconds between simulation frames
var C = 3.25;               // local speed of light. 
 
// UI
export function sliderGravity(v) {
  gravity = -14.3 * (0.02+v);
}

// overall simulation speed in ms per frame
export function sliderSpeed(v) {
  speed = 150 * (1-v);
}

var last_n = numParticles;
export function sliderParticles(v) {
  numParticles = 1+floor(v * (MAX_PARTICLES-1))
  
// we zero velocity vectors to get a restart when the
// number of particles changes.
  if (last_n != numParticles) {
    initParticles();
    clearFn = clearFrameBuffer;
    frameTime = 9999;
    last_n = numParticles;
  }
}

// we need two particle buffers so we can calculate every particle's
// instantaneous effect on every other particle. Instead of copying,
// we swap pointers on each frame.
var pb1 = array(MAX_PARTICLES);  
var pb2 = array(MAX_PARTICLES);
var particles,work_particles;


function allocateFrameBuffer() {
  for (var i = 0; i < height; i ++) {
    frameBuffer[i] = array(width);
  }
}

// zero entire frame buffer
function clearFrameBuffer() {
  for (var y = 0; y < height; y++) {
    for (var x = 0; x < width; x++) {
      frameBuffer[x][y] = 0;
    }
  } 
  clearFn = eraseParticles;
}

// not used by this version, but later...
function coolFrameBuffer() {
  for (var y = 0; y < height; y++) {
    for (var x = 0; x < width; x++) {
      frameBuffer[x][y] = max(0,frameBuffer[x][y] - 0.05);
    }
  } 
}

// erase only the dots we drew last frame.  Much faster than
// full clear.
function eraseParticles() {
  for (var i = 0;i < numParticles; i++) {
    frameBuffer[particles[i][_x]][particles[i][_y]] = 0;
  }
}

// allocate memory for particle tables
function allocateParticleLists() {
  for (var i = 0; i < MAX_PARTICLES; i ++) {
    pb1[i] = array(5);
    pb2[i] = array(5); 
  }
}

// set particles to random positions, 0 initial velocity
// all movement is generated by gravity!
function initParticles() {
  particles = pb1;
  work_particles = pb2;
  var hue = 0.001;
  
  for (var i = 0; i < MAX_PARTICLES; i ++) {
    particles[i][_x] = random(width);
    particles[i][_y] = random(height);
    particles[i][_dx] = 0;
    particles[i][_dy] = 0;
    particles[i][_hue] = hue;
    hue = (hue + 0.27) % 1
  }  
}

function swapParticleBuffers()  {
  var tmp = work_particles;
  work_particles = particles;
  particles = tmp;
}

function moveParticles() {
  for (var i = 0; i < numParticles; i++) {
    accel_x = 0;
    accel_y = 0;
    for (var j = 0; j < numParticles; j++) {   
      if (i == j) {
        continue;  // you aren't moved by your own gravity
      }
      // calculate effect of gravity between two particles
      // force of gravity decreases with distance, except that
      // "escape velocity" isn't possible, so particles can't just walk
      // out of our simulation. All particles are considered to have
      // a mass of 1.
      var dx = (particles[i][_x] - particles[j][_x]);
      var dy = (particles[i][_y] - particles[j][_y]);
       
      var r = sqrt(dx*dx + dy*dy);
      var f = (r > 1) ? gravity / r * r : gravity;
      accel_x += f * dx / r;   
      accel_y += f * dy / r;
    }
    // calculate new velocity and limit it to C - the local speed of light
    work_particles[i][_dx] = clamp(particles[i][_dx] + (accel_x / 100),-C,C);
    work_particles[i][_dy] = clamp(particles[i][_dy] + (accel_y / 100),-C,C); 

    work_particles[i][_hue] = particles[i][_hue];

    // calculate new location based on velocity, and wrap around
    // the edges of our display.  Note that a wrapping universe
    // makes things a little weird!
    work_particles[i][_x] = particles[i][_x] + work_particles[i][_dx];
    if (work_particles[i][_x] < 0) { work_particles[i][_x] = width - 1; }
    else if ((work_particles[i][_x] >= width)) { work_particles[i][_x] = 0; }
    
    work_particles[i][_y] = particles[i][_y] + work_particles[i][_dy];
    if (work_particles[i][_y] < 0) { work_particles[i][_y] = height - 1; }
    else if ((work_particles[i][_y] >= height)) { work_particles[i][_y] = 0; }

    // draw the particle into our frame buffer    
    frameBuffer[work_particles[i][_x]][work_particles[i][_y]] = particles[i][_hue];
  }
  swapParticleBuffers();
}

// Initialization
allocateFrameBuffer();
allocateParticleLists();
initParticles();

export function beforeRender(delta) {
  frameTimer += delta;
  
  if (frameTimer > speed) {
    clearFn();
    moveParticles();
    frameTimer = 0;
  }
}

export function render2D(index, x, y) {
  var v = frameBuffer[(x * 16)][(y * 16)];
  hsv(v, 1, (v > 0) * 0.6);
}